<p>If you’ve been browsing mechanical keyboard communities, and especially the niche that is ergonomic mechanical keyboards, you may have come across the term “home row mods” and wondered what could that mean. Well, wonder no more for I shall explain!</p>

<h1 id="what-are-home-row-mods">What are home row mods?</h1>

<p>Let’s first deconstruct the term. The “home row” refers to the middle row of alpha keys. On an English QWERTY keyboard this would be
<kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> <kbd>F</kbd> <kbd>G</kbd> <kbd>H</kbd> <kbd>J</kbd> <kbd>K</kbd> <kbd>L</kbd> <kbd>;</kbd>.
This row is called the “<em>home</em> row” because if one were to follow touch typing technique, this is the row of keys on which your fingers are supposed to rest on. The bars or the dish found on <kbd>F</kbd> and <kbd>J</kbd> help to find back the home position without looking at the keyboard — this is especially important for relatively big keyboards which require you to move your hands to hit some of the keys like for example <kbd>Backspace</kbd> or the arrow keys on a classic <abbr title="Ten Key Less">TKL</abbr> and thus throw you off home position.</p>

<p><img src="https://hygo.com/wp-content/uploads/2017/06/f-j-5-bumps-on-keyboard.jpg" alt="Zoom in on a keyboard with grey QWERTY keycaps with the F and J keys circled in red" /></p>

<p>Next is “mods”. What is meant by “mods”? In this case, “mods” refer to modifiers, that is to say <kbd>⇧ Shift</kbd>, <kbd>⎈ Control</kbd>, <kbd>⎇ Alt</kbd>, and <kbd>◆ GUI</kbd> (also known as WinKey on Windows, Command on MacOS or Super/Meta on Linux and BSD). So this means that “home row mods” are about placing modifiers on the home row.</p>

<p>How can that be possible? Does this mean that the home row letters/symbols swap positions with the modifier keys? Most certainly not! You see, one of the untapped potential of modifiers that are active as long as you hold them is that they don’t do anything useful when they’re tapped (i.e. pressed and released) on its own — a notable exception is the Win/Super key which opens the start menu on Windows and Gnome — but thanks to software like <a href="https://docs.qmk.fm/#/">QMK</a>, we can turn these momentary switch modifiers into dual-role keys which act as modifiers when held but act as other keys when tapped. This allows us to make more with less.</p>

<p>The name QMK gives to this functionality is “mod-tap”. Other software which also implement this functionality call it differently. <!-- Wikipedia seems to have a page on dual-role keys: http://en.wikipedia.org/wiki/Modifier_key#Dual-role_keys --> Therefore, we really should say “home row mod-taps” but in common parlance, “home row mods” is what’s always used.</p>

<p>We now know <em>what</em> home row mods are; it is the practice of turning the home row keys into mod-taps. We have yet to figure out <em>why</em> use home row mods.</p>

<h1 id="why-use-home-row-mods">Why use home row mods?</h1>

<p>The reason why would anyone choose to use home row mods are quite simple. A keyboard is no longer used exclusively for text input. It is also used to navigate and operate a computer, launch programs, format text, execute macros, zoom in and out, change input language and so much more which goes beyond simply typing letters. Modifiers play a big role in those functions.</p>

<p>Obviously, typewriters did not have any of those functions. They could only type. The modifier keys that we use so much now were added afterwards, kind of as an afterthought, over the classic typewriter layout which plagues us to this day. It was decided to reduce the width of the spacebar in order to make space for the modifier keys that were needed for the computer age.</p>

<figure>
<a href="https://genevatypewriters.blogspot.com/2010/11/variations-on-typewriter-keyboard.html">
        <img src="https://4.bp.blogspot.com/_8pq4w7Eq5-Q/TO2K1vc3MMI/AAAAAAAABiA/rr6e91NHUqc/s1600/IMG_0830.JPG" alt="A photo of an Italian QZERTY keyboard/typewriter on a Hermes Baby" title="An Italian QZERTY typewriter on a Hermes Baby" />
</a>
<figcaption> On some typewriters, the spacebar was ｒｉｄｉｃｕｌｏｕｓｌｙ ｗｉｄｅ.  </figcaption>
</figure>

<p>As a consequence, you need to do all sorts of finger gymnastics in order to trigger keyboard shortcuts. Not only are you playing Twister with your fingers, you’re straining the weakest finger the most in order to hold the necessary modifiers.</p>

<p>It is in your best interest to find a solution at the risk of maybe getting RSI and Emacs pinky one day. This is especially important for programmers as most of their keyboard usage isn’t actually typing symbols but triggering commands with a plethora of different keyboard shortcuts. Though any power user of any application, not just programmers in their text editor, uses keyboard shortcuts extensively.</p>

<p>Home row mods are about the best solution to this modifier problem. The fact that there are four modifiers, each coming with a left hand and right hand version perfectly matches the eight fingers resting on the home row. We can put a modifier right under each finger and mirror it on both hands.</p>

<p>Isn’t it great to have ALL the modifiers at our finger tips? No motion, stretching or strain required. This rapid access to modifier chords is very comfortable and allows to blend the execution of keyboard shortcuts in the typing flow, whereas it previously required a context switch to stop composing text, move the hands to the corner(s) of the keyboard, trigger the desired keyboard shortcut and then find back the homing position to continue touch typing text.</p>

<p>The other benefit of having all the modifiers lined up in a row and each dedicated a specific finger is that you can trigger ANY keyboard shortcut with ease.
<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>GUI</kbd>+<kbd>Alt</kbd>
is an insanity on a standard keyboard but with home row mods, it is trivial: just hold down the four fingers of your hand on the keys you’re already resting on. Dedicating a specific finger for each of the four modifier also gives your pinky a well deserved break. Home row mods are also advantageous for the thumbs, for it frees them up for something else like layer switches or <a href="https://precondition.github.io/pressing-e-with-the-thumb">even letters</a>. In fact, home row mods and layer thumb keys are a perfect fit. It makes it very easy to chord layers and modifiers together without forcing finger contortions or same finger utilization.</p>

<p>Finally, home row mods (or variations of the concept which we’ll talk about later in the article) is the secret sauce to making all those tiny 30% keyboards<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> that you’ve always deemed to be too small to be usable,… actually usable.</p>

<!-- Add gallery of 30%'s -->

<p>Are you convinced? If so, let’s now look at the <em>how</em>.</p>

<h1 id="how-to-use-home-row-mods">How to use home row mods?</h1>

<p>For the best home row mods experience, I heartily recommend a QMK-powered mechanical keyboard. At the time of writing, QMK supports over 570 keyboards! The greater part of which are DIY keyboards.</p>

<p>The following section will be about implementing home row mods in a QMK-powered keyboard with all the necessary settings to make it work well.</p>

<p>For those of you who do not have a QMK-powered board (or those who miss their home row mods when typing on laptop or on any other non-QMK keyboard), you will find a guide for implementing home row mods using <a href="https://github.com/david-janssen/kmonad">KMonad</a> just after the section on QMK.</p>

<h2 id="using-home-row-mods-with-qmk">Using home row mods with QMK</h2>

<p>As previously said, the way to create a dual-role key is to use what’s known as a “mod-tap” in QMK.
The mod-tap key <code class="highlighter-rouge">MT(mod, kc)</code> acts like a modifier when held, and a regular keycode when tapped. In other words, this is what allows us to have a key that sends “a” when you tap it, but function as a <kbd>⇧ Shift</kbd> or <kbd>⎈ Control</kbd> key when you hold it down. Note that the fact that we’ve turned <code class="highlighter-rouge">KC_A</code> into a mod-tap does not make it impossible to use keyboard shortcuts involving the letter “A”. You can still do <kbd>Shift</kbd>+<kbd>A</kbd> or <kbd>Alt</kbd>+<kbd>A</kbd> just fine.
Although, depending on what modifier you decided to assign to <kbd>A</kbd>, you’ll need to use the opposite hand to combine that modifier with “A”.</p>

<p>Let me explain with an example. Let’s take the home row mod setup illustrated in the cover image of this blog post.</p>

<p><img src="assets/images/home-row-mods/dark-QWERTY-home-row-mods___side-legends.png" alt="KLE render of dark blue QWERTY home row keycaps with mod icons in the center and mod name on the side of the keycaps" /></p>

<p>This setup, translated into code would look something like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MT</span><span class="p">(</span><span class="n">MOD_LGUI</span><span class="p">,</span> <span class="n">KC_A</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_LALT</span><span class="p">,</span> <span class="n">KC_S</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_LSFT</span><span class="p">,</span> <span class="n">KC_D</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_LCTL</span><span class="p">,</span> <span class="n">KC_F</span><span class="p">),</span> 

<span class="n">MT</span><span class="p">(</span><span class="n">MOD_RCTL</span><span class="p">,</span> <span class="n">KC_J</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_RSFT</span><span class="p">,</span> <span class="n">KC_K</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_LALT</span><span class="p">,</span> <span class="n">KC_L</span><span class="p">),</span> <span class="n">MT</span><span class="p">(</span><span class="n">MOD_RGUI</span><span class="p">,</span> <span class="n">KC_SCLN</span><span class="p">)</span>
</code></pre></div></div>

<p>Or if one were to use the shortcuts documented <a href="https://docs.qmk.fm/#/mod_tap">here</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LGUI_T</span><span class="p">(</span><span class="n">KC_A</span><span class="p">),</span> <span class="n">LALT_T</span><span class="p">(</span><span class="n">KC_S</span><span class="p">),</span> <span class="n">LSFT_T</span><span class="p">(</span><span class="n">KC_D</span><span class="p">),</span> <span class="n">LCTL_T</span><span class="p">(</span><span class="n">KC_F</span><span class="p">),</span> 

<span class="n">RCTL_T</span><span class="p">(</span><span class="n">KC_J</span><span class="p">),</span> <span class="n">RSFT_T</span><span class="p">(</span><span class="n">KC_K</span><span class="p">),</span> <span class="n">LALT_T</span><span class="p">(</span><span class="n">KC_L</span><span class="p">),</span> <span class="n">RGUI_T</span><span class="p">(</span><span class="n">KC_SCLN</span><span class="p">)</span>
</code></pre></div></div>
<p>As you can see in this example, <kbd>A</kbd> is a <code class="highlighter-rouge">LGUI</code> mod-tap. This means that tapping the key will produce “a” and holding it will activate the left GUI modifier. If that was the only GUI mod-tap in your keymap, this would make it impossible to trigger the
<kbd>GUI</kbd>+<kbd>A</kbd>
keyboard shortcut. This is where mirroring all the modifiers on the other hand comes in handy. If you want to do
<kbd>GUI</kbd>+<kbd>A</kbd>, you’ll have to hold <code class="highlighter-rouge">MT(MOD_RGUI, KC_SCLN)</code>, i.e. the semicolon key in our example, and tap <code class="highlighter-rouge">MT(MOD_LGUI, KC_A)</code>, i.e. our <kbd>A</kbd> key.</p>

<p>Now, you’ve probably noticed that all the left hand keys are assigned left hand modifiers and all the right hand keys are assigned right hand modifiers with the exception of <kbd>⎇ Alt</kbd>. The reason why I haven’t used <code class="highlighter-rouge">RALT</code> is that, while most right-hand modifiers act exactly the same as their left-hand counterpart, this is not necessarily the case for <kbd>⎇ Alt</kbd>. On some layouts, the right Alt becomes <kbd>AltGr</kbd> which is used as a momentary layer switch to access additional symbols. Keep this in mind when composing your right hand home row mods or you might get a surprise!</p>

<p>If this odd case bothers you, you can use left hand modifiers for all the home row mods. Separating left hand and right hand modifiers, as done in the example, is not strictly necessary for a functioning setup but doing so offers some perks.</p>

<p>First of all, it allows to hop from one modifier to its counterpart fluidly. What do I mean? Let’s say you want to produce, using the home row mods setup illustrated above, capital “Q” which we’ll assume is situated on the left hand of your keyboard. To do that, imagine you first hold <code class="highlighter-rouge">MT(MOD_LSFT, KC_D)</code> to activate shift but then you realize that this is the wrong shift (proper touch typing technique advocates for the use of the opposite hand when shifting letters).</p>

<p>To remedy this, press and hold <code class="highlighter-rouge">MT(MOD_RSFT, KC_K)</code> without releasing your finger off <code class="highlighter-rouge">MT(MOD_LSFT, KC_D)</code> and then, while you’re keeping <code class="highlighter-rouge">MT(MOD_RSFT, KC_K)</code> pressed, release <code class="highlighter-rouge">MT(MOD_LSFT, KC_D)</code>.
At this stage, you’re now holding shift with only the right hand and can now tap <kbd>Q</kbd> to produce “Q”.</p>

<p>If, instead, your <kbd>K</kbd> key was <code class="highlighter-rouge">MT(MOD_LSFT, KC_K)</code>, you wouldn’t be able to do that. If you hold both shift mod-taps and then release the one on the left half of the keyboard, holding the shift mod-tap on the right side loses all its effects when you lift up your left middle finger. It is not doing anything. So when you tap <kbd>Q</kbd> while holding the right-hand shift mod-tap, you’ll get lowercase “q”.</p>

<!-- insert KLE gif -->

<p>The only way to properly hop modifiers when both of them are programmed to send the exact same modifier, is to fully release the wrong mod-tap you’ve first pressed before pressing and holding the correct one, on the opposite hand. There is a catch though. If you realize early on that this is the incorrect hand to use the modifier with, you will instinctively fully release the incorrect mod-tap in order to hop to the correct one but if you release the incorrect mod before the tapping term, which is very likely to happen unless you’re slow at catching yourself using the wrong hand for the modifier, that will be considered as a tap by the firmware and will thus send the tap keycode, “f” in our case. Doing so thus puts you at risk of accidental alphas when hopping modifiers.</p>

<p>Secondly, distinguishing between home row mods of the left hand from home row mods of the right hand can be useful if you want to detect typing rolls.</p>

<p>Let’s look into the situation where one uses home row mods on a keyboard layout that favors rolls. The most famous rolls-focused keyboard layout is Colemak, so we’ll use the following home row mods setup as a case study.</p>

<p>Let’s imagine that this Colemak user is aiming for the lowest tapping term on his shift mod-taps in order to capitalize letters in a faster and more responsive way. He’s gone so low on the tapping term of his shift mod-taps, that rolling over <kbd>S</kbd> and <kbd>T</kbd> produces “T” instead of the expected “st”. Same story for rolls over <kbd>E</kbd> and <kbd>N</kbd>.
If he’s otherwise happy with the tapping term of his shift mod-taps, what can he do to help him type “The first event” rapidly and accurately without ending up with “The firT evNt” instead?</p>

<p>It is tempting to say that he should use <code class="highlighter-rouge">TAPPING_TERM_PER_KEY</code> and increase the tapping term of his shift mod-taps in order to reduce the accidental mod activations but aside from the “st” and “en” bigrams, this user is satisfied with the speed of activation of shift for every other combination of letters. Increasing the tapping term will probably help with rolling “st” and “en” but it will also ever so slightly affect every other bigram involving “s” or “e”. 
This hypothetical user can either adapt himself to it (not hard) or if he really wants to, he can adapt the firmware <em>to himself</em>.</p>

<p>To do so, he can use this nifty piece of code in <code class="highlighter-rouge">process_record_user</code> which takes advantage of the distinction between left-hand shift and right-hand shift:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">mod_state</span><span class="p">;</span>
<span class="n">bool</span> <span class="nf">process_record_user</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">keycode</span><span class="p">,</span> <span class="n">keyrecord_t</span> <span class="o">*</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mod_state</span> <span class="o">=</span> <span class="n">get_mods</span><span class="p">();</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">keycode</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">case</span> <span class="n">RCTL_T</span><span class="p">(</span><span class="n">KC_N</span><span class="p">):</span>
        <span class="cm">/*
        This piece of code nullifies the effect of Right Shift when tapping
        the RCTL_T(KC_N) key.
        This helps rolling over RSFT_T(KC_E) and RCTL_T(KC_N)
        to obtain the intended "en" instead of "N".
        Consequently, capital N can only be obtained by tapping RCTL_T(KC_N)
        and holding LSFT_T(KC_S) (which is the left shift mod tap).
        */</span>
        
        <span class="cm">/*
        Detect the tap. 
        We're only interested in overriding the tap behaviour 
        in a certain cicumstance. The hold behaviour can stay the same.
        */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">tap</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Detect right shift
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">mod_state</span> <span class="o">&amp;</span> <span class="n">MOD_BIT</span><span class="p">(</span><span class="n">KC_RSHIFT</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// temporarily disable right shift
</span>                <span class="c1">// so that we can send KC_E and KC_N
</span>                <span class="c1">// without shift on.
</span>                <span class="n">unregister_code</span><span class="p">(</span><span class="n">KC_RSHIFT</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">KC_E</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">KC_N</span><span class="p">);</span>
                <span class="c1">// restore the mod state
</span>                <span class="n">set_mods</span><span class="p">(</span><span class="n">mod_state</span><span class="p">);</span>
                <span class="c1">// to prevent QMK from processing RCTL_T(KC_N) as usual in our special case
</span>                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> 
            <span class="p">}</span>
        <span class="p">}</span>
         <span class="cm">/*else process RCTL_T(KC_N) as usual.*/</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">LCTL_T</span><span class="p">(</span><span class="n">KC_T</span><span class="p">):</span>
        <span class="cm">/*
        This piece of code nullifies the effect of Left Shift when
        tapping the LCTL_T(KC_T) key.
        This helps rolling over LSFT_T(KC_S) and LCTL_T(KC_T)
        to obtain the intended "st" instead of "T".
        Consequently, capital T can only be obtained by tapping LCTL_T(KC_T)
        and holding RSFT_T(KC_E) (which is the right shift mod tap).
        */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">tap</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mod_state</span> <span class="o">&amp;</span> <span class="n">MOD_BIT</span><span class="p">(</span><span class="n">KC_LSHIFT</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">unregister_code</span><span class="p">(</span><span class="n">KC_LSHIFT</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">KC_S</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">KC_T</span><span class="p">);</span>
                <span class="n">set_mods</span><span class="p">(</span><span class="n">mod_state</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
         <span class="cm">/*else process LCTL_T(KC_T) as usual.*/</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>If you have a different setup because you neither use Colemak nor use the GASC/◆⎇⇧⎈ home row mods order, but are interested in using this trick, here are the parameters you need to change:</p>

<p>Let <code class="highlighter-rouge">LSFT_T(l_s_letter)</code> equal your left hand home row shift mod-tap, 
    <code class="highlighter-rouge">LMOD_T(l_letter)</code> equal your left hand home row non-shift mod-tap (it can be any mod, that will depend on what you’ve put near your home row shift mod-tap),
and vice versa for the right hand;
     <code class="highlighter-rouge">RSFT_T(r_s_letter)</code>,
     <code class="highlighter-rouge">RMOD_T(r_letter)</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="nf">RMOD_T</span><span class="p">(</span><span class="n">r_letter</span><span class="p">)</span><span class="o">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">tap</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mod_state</span> <span class="o">&amp;</span> <span class="n">MOD_BIT</span><span class="p">(</span><span class="n">KC_RSHIFT</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">unregister_code</span><span class="p">(</span><span class="n">KC_RSHIFT</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">r_s_letter</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">r_letter</span><span class="p">);</span>
                <span class="n">set_mods</span><span class="p">(</span><span class="n">mod_state</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> 
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">case</span> <span class="nf">LMOD_T</span><span class="p">(</span><span class="n">l_letter</span><span class="p">)</span><span class="o">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">tap</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mod_state</span> <span class="o">&amp;</span> <span class="n">MOD_BIT</span><span class="p">(</span><span class="n">KC_LSHIFT</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">unregister_code</span><span class="p">(</span><span class="n">KC_LSHIFT</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">l_s_letter</span><span class="p">);</span>
                <span class="n">tap_code</span><span class="p">(</span><span class="n">l_letter</span><span class="p">);</span>
                <span class="n">set_mods</span><span class="p">(</span><span class="n">mod_state</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p>This trick is about cancelling the effet of home row shift mod-tap on a nearby home row mod-tap but nothing prevents you from cancelling the effect of home row non-shift mod-tap on another key that isn’t even a mod-tap at all. It can be generalized.</p>

<p>Sticking with the Colemak example, imagine you have repetitive accidental mod activations when doing <code class="highlighter-rouge">RGUI_T(KC_O)</code>+<code class="highlighter-rouge">KC_U</code> when rolling keys for the bigram “ou”. You can add a case in your <code class="highlighter-rouge">process_record_user</code> for <code class="highlighter-rouge">KC_U</code> where you check the mod state for RGUI and override the default behaviour by sending “ou” instead of <kbd>◆ GUI</kbd>+<kbd>U</kbd>.</p>

<!-- Link to manna's bilateral combinations -->

<p>That being said, I want to clarify that this trick is most definitely not necessary for an enjoyable home row mods experience.
I’ve mentioned it here just to give another example why you might want to distinguish between right hand and left hand home row mods. You don’t need to go this far.</p>

<p>However, the following tap hold configuration settings <em>are</em> important for home row mods.</p>

<h3 id="tap-hold-configuration-settings">Tap Hold configuration settings</h3>

<p>Here comes the most difficult part; understanding the different tap hold configuration settings.</p>

<p>I strongly advise you to attentively read through the <a href="https://docs.qmk.fm/#/tap_hold">official QMK documentation page on tap hold configuration settings</a>, <a href="https://github.com/qmk/qmk_firmware/blob/155cc17359711a6dd7b67119ec994800588ebaaa/docs/tap_hold.md">the proposed changes to the documentation</a><sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> by <a href="https://github.com/sigprof">sigprof</a> on <abbr title="Pull Request">PR</abbr> <a href="https://github.com/qmk/qmk_firmware/pull/9404">#9404</a>, and <a href="https://github.com/okke-formsma/">Okke</a>’s <a href="https://cdn.discordapp.com/attachments/663573863480950808/757162393209012304/modtap.pdf">cheatsheet on MT and LT behaviour</a>.<sup>[PDF]</sup></p>

<h4 id="ignore-mod-tap-interrupt">Ignore Mod-Tap Interrupt</h4>

<p>Suffice to say that <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> is <em>the</em> most important tap hold configuration settings that’s absolutely necessary for a good home row mods experience.</p>

<p>Why is it so important and relevant to home row mods? To understand, let’s look at the default behaviour for mod-taps. The underlying logic of basic mod-taps is quite simple. Did another key get pressed while the user was holding down the mod-tap key? If that’s the case, this is a keyboard shortcut; apply the modifier on that pressed key. What if, instead, no key got pressed while the user was holding down the mod-tap? Well, if the user presses and releases a key by itself, without pressing any other key in between, it must mean the user wanted the tapping function of the mod-tap since there is no use to tapping a modifier key all by itself<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. Simple enough right? If you want to activate the holding function, just press on another key while holding the mod-tap key.</p>

<p>Here comes the problem with that approach if one were to use home row mods. We like to imagine typing as tapping a sequence of keys all on their own, in order. However, there’s quite some overlap between the press and release of each key. Especially so when typing at high speeds. When typing the word “no” for example, we rarely press and fully release <kbd>N</kbd> <em>before</em> pressing <kbd>O</kbd>. Try it! If you’re not a hunt’n’pecker, this is how you’re most likely going to type “no”:</p>

<ul>
  <li><kbd>N</kbd> Down/Press</li>
  <li><kbd>O</kbd> Down/Press</li>
  <li><kbd>N</kbd> Up/Release</li>
  <li><kbd>O</kbd> Up/Release
<!-- Maybe add a KLE gif of typing "no" like that on the side of this bullet list --></li>
</ul>

<p>Now imagine if <kbd>N</kbd> and <kbd>O</kbd> were both mod-taps — it would be the case if you use home row mods on Colemak for example. With default tap hold settings, this is bad news. Indeed, typing involves a lot of such rolls, where you press the next letter before having fully released the previous one.</p>

<p>This is the reason why <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> was developed and first <a href="https://github.com/qmk/qmk_firmware/commit/f024a462cdaa4a7a345160819bdf2d01fbabc97a">released in 2015</a> by <a href="https://github.com/ezuk">Erez Zukerman</a>. Though Erez didn’t have home row mods in mind when coming up with this solution. In fact, it actually took two more years after the addition of <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> to QMK for the <a href="https://github.com/qmk/qmk_firmware/blob/82de4d039d39c87a1df68708f3033926c27f7e6c/keyboards/ergodox/keymaps/adam/keymap.c#L52">first commit</a> to the main branch of the QMK firmware GitHub repository to feature home row mods.<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup></p>

<p>Anyways, thanks to his contribution, we now have an option for ignoring key presses that interrupt a mod-tap. That is to say, keys which get pressed while the mod-tap is held down do not automatically activate the modifier of the mod-tap. The mod-tap ignores the interruptions, hence the name.</p>

<p>Now, you might wonder… If mod-taps ignore key presses that happen while it is held down, what do they base themselves on to determine when to activate the modifier and when to send the basic keycode? The answer is that it relies on the tapping term, a user defined period of time which starts when the key gets pressed. Been holding the mod-tap for more than the time defined in the tapping term? Activate the modifier. Pressed the key and then released it before the tapping term expired? That’s the QMK definition of a “tap”, send the letter!</p>

<p>As long as your fingers don’t linger on the keys for longer than the tapping term, you won’t get accidental mod activations.</p>

<h4 id="tapping-term">Tapping Term</h4>

<p>The tapping term is an important concept to grasp for home row mods. As we’ve just seen in the previous section on ignore mod tap interrupt, the tapping term is what helps to tell tap, and hold apart.</p>

<p>The tapping term, in and of itself, is a very basic thing to understand. It is simply a period of time expressed in milliseconds that the user has defined. A timer starts on every key press and constantly checks whether the tapping term for that key has expired yet or not. The timer stops when the key is released. It is good to note that each pressed key is tracked by a specific, different timer, so to speak.</p>

<p>Since a tap is defined as the act of pressing and releasing a key within <strong>tap</strong>ping term, the tapping term can be seen as the time window in which you need to release the key in order to register a tap. On the flip side, it can also be seen as the minimum amount of time a key must be held down to register a hold.</p>

<p>As such, a good tapping term that fits you is one that prevents accidental mod activations and keeps the intended mod activations snappy. It is a delicate balance.</p>

<p>The tapping term can be configured globally and per key to fit you. In general, people choose something between 150ms and 220ms, with the default QMK setting for the tapping term set at 200ms. Don’t be scared to increase or decrease your tapping term as you see fit.</p>

<p>For tips on configuring your tapping term and finding the sweet spot for you, head to the Tips &amp; Tricks section of this guide.</p>

<h4 id="tapping-force-hold">Tapping Force Hold</h4>

<p>The third very important tap hold setting for home row mods is <code class="highlighter-rouge">TAPPING_FORCE_HOLD</code>.</p>

<p>Over the course of normal computer usage, you will switch back and forth between typing and triggering keyboard shortcuts. When the modifiers are on the home row, sooner or later, you will feel the need to press a home row key to type a letter and then pressing that same key in order to activate a modifier. However, the default behaviour for a quick tap followed by a hold is to auto-repeat the tapping function of the mod-tap.</p>

<p>This means that if you use <code class="highlighter-rouge">LSFT_T(KC_L)</code> for example and you want to type “camelCase”, you will end up with “camelllllllllllllllllcase” instead. The reason is that you’re tapping <code class="highlighter-rouge">LSFT_T(KC_L)</code> to get “l” and then immediately after, you’re holding that same <code class="highlighter-rouge">LSFT_T(KC_L)</code> key to activate shift in order to type the capital “C” of “camel<strong>C</strong>ase”.</p>

<p>Avoiding this problem is easy; just append <code class="highlighter-rouge">#define TAPPING_FORCE_HOLD</code> to your <code class="highlighter-rouge">config.h</code> file in your personal keymap folder. This will have the effect of letting you activate the hold function instead, in the case of holding a dual-role key after having tapped it. No more accidental repeats of mod-tap letters when typing quickly!</p>

<p>The downside is that it removes the possibility of auto-repeating the letter/tapping function of the mod-tap. You will need to tap (press-release) repeatedly if you want to spam a letter.</p>

<p>Keep in mind that <code class="highlighter-rouge">TAPPING_FORCE_HOLD</code> is a universal configuration which applies on all dual-role keys (layer-taps and mod-taps). If your backspace key is a layer-tap, you may find that extremely limiting <!-- Find a better synonym for "extremely limiting" -->. The good news is that there exists a per-key variant of this configuration option: <code class="highlighter-rouge">TAPPING_FORCE_HOLD_PER_KEY</code>. Just follow the <a href="https://docs.qmk.fm/#/tap_hold?id=tapping-force-hold">instructions described in the docs</a> to enable <code class="highlighter-rouge">TAPPING_FORCE_HOLD</code> for home row mods and disable it for other layer taps as you see fit.</p>

<hr />

<p>That concludes it for the <em>essential</em> tap hold configuration settings for home row mods. Don’t try to use home row mods without <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> and <code class="highlighter-rouge">TAPPING_FORCE_HOLD</code> or with an insane <code class="highlighter-rouge">TAPPING_TERM</code>. You’ll have a bad time if you do and will come out of it thinking that “home row mods are not for me”.</p>

<p>Apart from these options, you may have noticed that QMK offers more tap hold configuration settings if you’ve read the documentation linked at the beginning of this section — please read through those links if you haven’t yet. While non-essential, they can still be <em>very useful</em> and a better understanding of them can help you enable the settings that will prove beneficial to you.</p>

<h4 id="permissive-hold">Permissive Hold</h4>

<p>First in the list is “permissive hold”. It is an option that adds another way to trigger the hold function of dual-role keys.</p>

<p>Whereas the modifier of the mod-tap is activated when another key gets <em>pressed</em> by default or gets activated when held down for longer than the tapping term if <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> is defined, permissive hold activates the modifier when another key is pressed and released while the mod-tap is held, regardless of the tapping term. This means that even when <code class="highlighter-rouge">IGNORE_MOD_TAP_INTERRUPT</code> is defined, this option allows the user to trigger a keyboard shortcut with a mod-tap key before the end of the tapping term.</p>

<p>Consider the following case:</p>

<ul>
  <li><code class="highlighter-rouge">RCTL_T(N)</code> Down/Press</li>
  <li><code class="highlighter-rouge">RGUI_T(O)</code> Down/Press</li>
  <li><code class="highlighter-rouge">RGUI_T(O)</code> Up/Release</li>
  <li><code class="highlighter-rouge">RCTL_T(N)</code> Up/Release</li>
</ul>

<p>In English, this is a situation when you’re tapping <kbd>O</kbd> while holding down <kbd>N</kbd>. It can also be called a “nested keypress”. If all of this happens before the end of the tapping term, the output, assuming mod-tap interrupts are ignored, would be “no”. Contrast this to the scenario when permissive hold is enabled where the output would instead be Ctrl+O.</p>

<p>As you can see, the assumption here is that if the user taps another key while holding down one or more mod-tap keys, he isn’t doing typing rolls and as such desires to trigger a keyboard shortcut instead. The tapping term is irrelevant here.</p>

<p>Consequently, this option allows the use of home row mods with a tapping term that’s much greater than 200ms. Though, people with a high tapping term aren’t the only ones who can benefit from this option. Fast typists who are used to swift taps and rolls can enable this option for snappier mod activations and thus bypass the need to wait out the tapping term for the modifiers to take effect.</p>

<p>Owing to the fact that permissive hold is… more permissive in what counts as a hold, it makes it easier to trigger mods so unintended mod activations can happen if the aforementioned case is something you frequently do when typing normally. Depending on your typing style, permissive hold might do more harm than good.</p>

<p>As with many other tap hold settings, there exists a global <code class="highlighter-rouge">PERMISSIVE_HOLD</code> setting and a per-key option, aptly named <code class="highlighter-rouge">PERMISSIVE_HOLD_PER_KEY</code>. Consult the [documentation] to figure out how to enable and configure this setting.
<!-- add link to permissive hold documentation --></p>

<h4 id="retro-tapping">Retro Tapping</h4>

<p>Remember how I said that there isn’t much use in pressing and releasing a modifier all by itself? Mod-taps (ab)use this property, but as it turns out mod-taps have the exact same property themselves. If you hold down a mod-tap for longer than the tapping term and then release it without having pressed any other key in between, your QMK keyboard is going to send a press and release event of the modifier to your computer; not too different from tapping a basic modifier key. If that seems wasteful for you, then let me introduce you retro tapping.</p>

<p>When a mod-tap is held for a long time and released on its own, retro tap will replace the holding function, which would be triggered usually, with the tapping function.</p>

<p>To give an example, if you press and hold <code class="highlighter-rouge">LGUI_T(KC_A)</code> for longer than the tapping term and then release it by itself, it is not <code class="highlighter-rouge">KC_LGUI</code> that will get sent but <code class="highlighter-rouge">KC_A</code>. Retro Tap gives another way to trigger the tapping function of mod-taps. With this option, you can get away with a very short tapping term.</p>

<p>However, this particular example highlights a potential problem with retro tap. In many popular desktop environments, the start menu is brought up by tapping the GUI key. Retro tap removes that possibility, it overrides modifier taps with a letter (or whatever keycode you’ve defined to be the tap keycode).</p>

<p>What if you use another way to bring up the start menu? You’ll still have a problem for navigating through menus of graphical applications with the keyboard since that requires tapping the alt modifier.</p>

<p>The Alt and GUI modifiers aren’t the only problem, think of the mouse too. The firmware that’s running on your board cannot tell that you have clicked or scrolled the mouse wheel while holding down a mod-tap key. All it sees is that you’ve been holding down a mod-tap for more than the tapping term and released it without pressing any other key in between. As we now know, this is the cue for the firmware to activate the tapping function of the mod-tap in question if retro tap is enabled. Ctrl+Left-Click to open a link in a new tab or Shift+Scrollwheel to scroll sideways can thus be kissed goodbye.</p>

<p>These limitations are obviously very annoying …
<!-- Contact Kerotonic or whatever is the name of the autoshift/retro tap guy on the QMK discord server --></p>

<!--
[^10]: The convention is to keep all keycode names strictly under 8 characters long in order to keep a tidy, aligned and readable layout macro in the `keymap.c` file.

```c
// Left-hand home row mods
#define HOME_A LGUI_T(KC_A)
#define HOME_R LALT_T(KC_R)
#define HOME_S LSFT_T(KC_S)
#define HOME_T LCTL_T(KC_T)

// Right-hand home row mods
#define HOME_O RGUI_T(KC_O)
#define HOME_I LALT_T(KC_I)
#define HOME_E RSFT_T(KC_E)
#define HOME_N RCTL_T(KC_N)
```

If you feel like `HOME_letter` is too vague, nothing prevents you from doing something like this:

```c
// Left-hand home row mods
#define GUI_A LGUI_T(KC_A)
#define ALT_R LALT_T(KC_R)
#define SFT_S LSFT_T(KC_S)
#define CTL_T LCTL_T(KC_T)

// Right-hand home row mods
#define GUI_O RGUI_T(KC_O)
#define ALT_I LALT_T(KC_I)
#define SFT_E RSFT_T(KC_E)
#define CTL_N RCTL_T(KC_N)
```
-->
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>The 30% form factor refers to 40%’s with the outer pinky columns shaved off. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>This links directly to a specific snapshot in the commit history of the proposed Tap Hold documentation page and may thus not be the latest version at the time you’re reading this. For the latest version, check the <a href="https://github.com/qmk/qmk_firmware/pull/9404/files">changed files tab of the PR</a>. Also keep in mind that this PR adds a new tap hold option called <code class="highlighter-rouge">HOLD_ON_OTHER_KEY_PRESS</code> which has yet to be merged into <code class="highlighter-rouge">qmk:master</code>. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Once again, the GUI modifier on Desktop Environments such as Windows or Gnome is an exception to this. And so is the Alt modifier, which can be used as a leader key to navigate the menus of graphical applications. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>I’m not exactly sure whether this is really the very first time someone implemented home row mods (i.e. all the modifiers on the home row as mod-taps). If you find an earliest occurrence, which may or may not be implemented in QMK, let me know. For reference, I used the command <code class="highlighter-rouge">git log --before="2015-12-01" -G"[A-Z]+_T\(KC_[AS]\)"</code> in the <code class="highlighter-rouge">qmk_firmware</code> folder to find the first commit which contains <code class="highlighter-rouge">MOD_T(KC_A)</code> or  <code class="highlighter-rouge">MOD_T(KC_S)</code> as the letters A and/or S can be found in the home row of every layout. In case, you’re wondering about the <code class="highlighter-rouge">MT(mod, kc)</code> syntax, I also tried looking for the earliest match with the use of the command <code class="highlighter-rouge">git log --before="2015-12-01" -G"MT\(MOD_[A-Z]+, ?KC_[A-Z]\)"</code> but it did not return anything. In fact, the earliest commit which matches the pattern is <a href="https://github.com/qmk/qmk_firmware/commit/c037d4bb306613085a823e73f37653f1e71c0f0d">commit c037d4b</a> which dates from 2017! Though it is not the implementation of proper home row mods. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
